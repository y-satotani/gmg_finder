
\chapter{基本アルゴリズム}
\label{chap:basic-algorithm}
\ref{sect:generalized-moore-graph}節で示した一般化ムーアグラフの性質を利用して，
与えられた頂点数と次数の一般化ムーアグラフを探索する基本的なアルゴリズムを
深さ優先探索をベースに開発する．後の章で探索空間を縮小する手法の比較対象となる．
本章では，一般的な深さ優先探索の説明をしたあと，これを一般化ムーアグラフの探索に
適応する方法を示す．最後にアルゴリズムを示し，結果を与える．

\section{深さ優先探索}
\label{sect:depth-first-search}
深さ優先探索について説明する．理解している読者は\ref{sect:apply-to-gmg}節
まで読み飛ばして差し支えない．

\section{一般化ムーアグラフへの適応}
\label{sect:apply-to-gmg}
本節では，\ref{sect:depth-first-search}で説明した深さ優先探索を用いて，
一般化ムーアグラフを発見する方法を述べる．

\subsection{初期グラフと辺の候補}
\label{subsect:initial-graph}
探索の初期状態となる\textbf{初期グラフ}を定義し，候補となる辺を求める．まず，
初期グラフを構築する前に次を定義する．
\begin{definition}
  \textbf{ムーアバウンド}(\textbf{Moore bound})とは，
  次数が$k$,直径が$D$の正則グラフの頂点数の上界で，次式で定義される．
  \begin{equation}
    n_{k,D} = 1 + \sum_{i=1}^Dk(k-1)^{i-1}
  \end{equation}
\end{definition}
これは，$R=0$,$Q=D$かつ，次数が一致する一般化ムーアグラフの頂点数に等しい．

探索の初期状態となる初期グラフを次の手順で作成する．
\begin{enumerate}
\item 頂点$v\in\{2,\ldots,k+1\}$と，頂点$1$とを隣接させる．
\item 頂点$v\in\{k+2,\ldots,n-R+1\}$と，次の式で求められる頂点番号の
  頂点$w$とを隣接させる．
  \[ w=\left\lceil\frac{v-n_{k,\hat{Q}(v)-1}}{k-1}\right\rceil
  +n_{k,\hat{Q}(v)-2}\]
\end{enumerate}
このとき，残りの$R$個の頂点は孤立点であることに注意する．

初期グラフ$G_I$を構築した後，$G_I$上での次数が$k$未満の頂点同士を
隣接させる，次の辺の列を考える．
\[ E = \{e_i\} = \{(v_i,w_i)\,|\,
d_{G_I}(v_i)<k,d_{G_I}(w_i)<k,v_i<w_i,v_i\in V,w_i\in V\}
\setminus E(G_I) \]
探索では，$e_1,\ldots,e_m\in E$と順番に辺を取り出し，
グラフに追加する/しないを判定して新たなグラフを作ることを繰り返す．

\begin{example}
  図\ref{fig:initial-tree-example}に頂点数12,次数3の初期グラフを示す．
  あわせて，図\ref{fig:feasible-edges-example}にその候補辺を示す．
  \begin{figure}
    \centering
    \begin{minipage}{.4\columnwidth}
      \def\svgwidth{\textwidth}
      \input{initial-tree-example.pdf_tex}
      \captionof{figure}{頂点数12,次数3の初期グラフ}
      \label{fig:initial-tree-example}
    \end{minipage}
    \hfill
    \begin{minipage}{.4\columnwidth}
      \def\svgwidth{\textwidth}
      \input{feasible-edges-example.pdf_tex}
      \captionof{figure}{頂点数12,次数3の辺の候補}
      \label{fig:feasible-edges-example}
    \end{minipage}
  \end{figure}
\end{example}

最後に，初期グラフを構築するアルゴリズムをアルゴリズム
\ref{algo:basic-graph-initr}に示す．
\begin{algorithm}[H]
  \caption{初期グラフの構築}
  \label{algo:basic-graph-initr}
  \begin{algorithmic}[1]
    \Require $n,k$
    \Ensure 初期グラフ$G_I$
    \Procedure{Make initial graph}{$n,k$}
    \State $G_I\gets \varnothing$
    \ForAll{$v\in\{2,\ldots,k+1\}$}
    \State $E(G_I)\gets E(G_I)\cup\{(1,v)\}$
    \EndFor
    \ForAll{$v\in\{k+2,\ldots,n-R+1\}$}
    \State \parbox[t]{.6\linewidth}{
      $w\gets \left\lceil(v-n_{k,\hat{Q}(v)-1})/(k-1)\right\rceil$
      $+n_{k,\hat{Q}(v)-2}$
    }
    \State $E(G_I)\gets E(G_I)\cup\{(w,v)\}$
    \EndFor
    \State \textbf{return} $G_I$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection{可能な辺の追加/無追加}
\label{subsect:feasible-edge-(no)-addition}
探索途中の状態(本章では，グラフ$G$)と辺$e_i$が与えられたとき，
辺$e_i$を追加した後のグラフおよび追加しない後のグラフが
定理\ref{thm:gmg-geometric-property}を満たすか
判定する方法を与える．はじめに，いくつかの記号を導入する．
\begin{definition}
  頂点$v$に対して，それと接する辺$e_i$の$i$の
  最小値$i_{<v}$と最大値$i_{v>}$を考える．
  $i_{<v}$は探索中，初めて$v$と接する辺の番号を，
  $i_{v>}$は探索中に最後に$v$と接する辺の番号をそれぞれ表す．
  $i_{<v}$と$i_{v>}$の具体的な式は，次で与えられる．
  \begin{equation}
    \label{eq:frontier}
    \begin{aligned}
    i_{<v} &= \min(i\,|\,\{v,w\}=e_i) \\
    i_{v>} &= \max(i\,|\,\{v,w\}=e_i)
    \end{aligned}
  \end{equation}
\end{definition}

以上を踏まえて，辺$e_i$を追加した後のグラフと追加しない後のグラフが
定理\ref{thm:gmg-geometric-property}を満たすか判定する条件を述べる．
辺を$e_i=\{v,w\}$，元のグラフを$G$，操作後のグラフを$H$とする．
\begin{enumerate}
\item 追加する場合
  \begin{enumerate}
  \item 次数条件$\cdots$ $d_G(v)<k$かつ$d_G(w)<k$かつ，
    $i_{x>}=i$なる$x\in e_i$について，$d_H(x)=k$
  \item 閉路条件$\cdots$ $d_G(v,w)\geq2Q$\\
    (この条件を満たすとき，$e_i$によってできる閉路の長さは少なくとも
    $2Q+1$となり，定理\ref{thm:gmg-geometric-property}を満たす)
  \end{enumerate}
\item 追加しない場合
  \begin{enumerate}
  \item 次数条件$\cdots$ $i_{x>}=i$なる$x\in e_i$について，$d_H(x)=k$
  \end{enumerate}
\end{enumerate}
追加する場合としない場合のそれぞれについて，条件をすべて満たしたときのみ，
次の辺$e_{i+1}$に対して判定を行う．
状態をスタックにプッシュし，あとでポップすることで実現する．

\begin{example}
  再び頂点数12,次数3の場合について考える．
  いくつかの辺を追加した後のグラフを図\ref{fig:feasible-edges-example2}に
  示す．図\ref{fig:feasible-edges-example2}に示した辺
  $\{9,10\}$と$\{9,11\}$と$\{9,12\}$について考える．
  辺$\{9,10\}$を追加すると，$d(9,10)=2$のため長さ3の閉路$\{4,\,9,\,10\}$が
  できてしまい，一般化ムーアグラフの条件を満たさなくなる．
  そのため，辺$\{9,10\}$は追加せず次の辺に進む．
  辺$\{9,11\}$についても同様で，長さ4の閉路ができてしまうため，辺を追加しない．
  辺$\{9,12\}$は，$d(9,12)=5$なので長さ6の閉路が複数できる．これは，
  $6>2Q$なので，辺を追加できる．
  \begin{figure}
    \centering
    \def\svgwidth{.5\textwidth}
    \input{feasible-edges-example2.pdf_tex}
    \caption{探索途中のグラフ}
    \label{fig:feasible-edges-example2}
  \end{figure}
\end{example}

最後の辺を判定した後，グラフ$G$が正則かつ
定理\ref{thm:gmg-geometric-property}を満たす場合，アルゴリズムは
$G$を一般化ムーアグラフを出力する．
判定するグラフがなくなったとき，アルゴリズムは一般化ムーアグラフが
(これ以上)存在しないことを出力する．

最後に，辺の追加判定のアルゴリズムをアルゴリズム\ref{algo:basic-state}に示す．
\begin{algorithm}[H]
  \caption{辺の追加判定}
  \label{algo:basic-state}
  \begin{algorithmic}[1]
    \Require $G,i$
    \Ensure 追加できる/できないことの可能性
    \Procedure{Can add}{$G,i$}
    \State $H\gets G\cup\{e_i\}$
    \State \textbf{return} \parbox[t]{\linewidth}{
      $d_G(v)<k$かつ$d_G(w)<k$かつ，\\
      $i_{x>}=i$なる$x\in e_i$について$d_H(x)=k$かつ， \\
      $d_G(v,w)\geq2Q$
    }
    \EndProcedure
    \Procedure{Can no add}{$G,i$}
    \State \textbf{return} $i_{x>}=i$なる$x\in e_i$について，$d_G(x)=k$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection{探索アルゴリズム}
\ref{subsect:initial-graph}と\ref{subsect:feasible-edge-(no)-addition}
で説明した事柄を用いて，深さ優先探索を一般化ムーアグラフの探索に適応する．
そのアルゴリズムをアルゴリズム\ref{algo:basic-algorithm}に示す．
\begin{algorithm}[H]
  \caption{一般化ムーアグラフの探索アルゴリズム}
  \label{algo:basic-algorithm}
  \begin{algorithmic}[1]
    \Require $n,k$
    \Ensure $M(n,k)\:$(見つからない場合，$\varnothing$を返す)
    \Procedure{Find generalized Moore graph}{}
    \State $G_I\gets$\Call{Make initial graph}{$n,k$}
    \State $E=\{e_i\}\gets $\parbox[t]{\linewidth}{
      $\{(v_i,w_i)\,|$
      $\,d_{G_I}(v_i)<k,d_{G_I}(w_i)<k,v_i<w_i,v_i\in V,w_i\in V\}$
      $\setminus E(G_I)$
    }
    \State $\mathrm{State}\gets((G_I,1))$
    \While{$|\mathrm{State}|>0$}
    \State $G,i\gets\mathrm{State}$の末尾の要素
    \State $\mathrm{State}$の末尾の要素を削除
    \If{$i=|E|$かつ，$G$が正則で定理\ref{thm:gmg-geometric-property}を満たす}
    \State \textbf{return} $G$
    \EndIf
    \If{\Call{Can no add}{$G,i$}}
    \State $\mathrm{State}$の末尾に$(G,i+1)$を追加
    \EndIf
    \If{\Call{Can add}{$G,i$}}
    \State $H\gets G\cup\{e_i\}$
    \State $\mathrm{State}$の末尾に$(H,i+1)$を追加
    \EndIf
    \EndWhile
    \State \textbf{return} $\varnothing$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}
アルゴリズム\ref{algo:basic-algorithm}に手を加えて，一般化ムーアグラフを
列挙することができる．
9行目のグラフ返却の前にスタック($\mathrm{State}$)を保存しておき，
次回以降の呼び出しの4行目で，保存したスタックから再開することで実現する．
列挙の結果に同型なグラフが含まれることがある．
アルゴリズム\ref{algo:basic-algorithm}において，6行目が実行される回数を
\textbf{展開状態数}と呼び，後の章で提案する高効率化の指標の一つとする．

\section{実験}
\label{sect:exp-basic-algorithm}
本章で提案したアルゴリズムに関する実験を行う．実験で以下の項目を測定する．
\begin{enumerate}
\item 探索開始から最初の一般化ムーアグラフの発見における
  \begin{enumerate}
  \item 時間
  \item 状態の取り出し回数
  \end{enumerate}
\item 一般化ムーアグラフの列挙における
  \begin{enumerate}
  \item グラフ数
  \end{enumerate}
\end{enumerate}
それぞれの実験を付録\ref{chap:program}で示した方法に従って行う．
本実験での実行環境は表\ref{tab:basic-algorithm-env}のとおりである．
\begin{table}
  \caption{第\ref{chap:basic-algorithm}章の実験の実行環境}
  \label{tab:basic-algorithm-env}
  \centering
  \begin{tabular}{ll}
    \hline
    プロセッサ & Intel® Core™ i7-4712HQ CPU @ 2.30GHz × 4 \\ \hline
    メインメモリ & 3.9GiB \\ \hline
    ベースシステム & Ubuntu 16.04.3 LTS 64 ビット \\ \hline
    仮想化 & Oracle VirtualBox バージョン 5.1.8 r111374 \\ \hline
    コンパイラ & gcc 5.4.0 \\ \hline
    グラフライブラリ & igraph 0.7.1-2.1 \\ \hline
    最適化フラグ & -Ofast \\ \hline
  \end{tabular}
\end{table}

\section{結果}
\label{sect:result-basic-algorithm}
次数が3のときの実験結果を示す．
探索開始から最初の一般化ムーアグラフの発見における探索時間と状態の
取り出し回数を図\ref{fig:basic-time}と図\ref{fig:basic-node}に
それぞれ示す．また，一般化ムーアグラフの列挙におけるグラフ数を
図\ref{fig:basic-full-graph}に示す．

\begin{figure}
  \centering
  \includegraphics{the-basic-time.pdf}
  \caption{最初の一般化ムーアグラフの発見までの時間}
  \label{fig:basic-time}
\end{figure}
\begin{figure}
  \centering
  \includegraphics{the-basic-node.pdf}
  \caption{最初の一般化ムーアグラフの発見までの展開状態数}
  \label{fig:basic-node}
\end{figure}
\begin{figure}
  \centering
  \includegraphics{the-basic-full-graph.pdf}
  \caption{列挙された一般化ムーアグラフの数}
  \label{fig:basic-full-graph}
\end{figure}

結果から，同一の$Q(n,k)$について，$R$が大きいほど値が増加していることが
推測される．
